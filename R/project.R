#' @title Projection function
#' @description
#' This function can be used to project the default \pkg{bdm} model forward in time assuming a constant catch (harvest) or harvest rate. Multiple alternative scenarios can be run simultaneously.
#' 
#' Model parameter values are sampled from the joint posterior distribution and a projection is performed for each sample. A correlated random walk of process error terms is assumed during the projection.
#' 
#' @param object a \code{bdm} class object containing a fit to the default model
#' @param harvest_project a constant harvest or harvest rate as a vector across alternative scenarios
#' @param time_project number of time steps for future projection
#' @param harvest_rate a \code{logical} value indicating whether or not \code{harvest_project} refers to the harvest (catch) or harvest rate (catch over biomass)
#' @param ... arguments to generic function (not used)
#' @return Returns a \code{list} containing the elements:
#' \describe{
#'  \item{\code{run}}{optional run label that will match the corresponding \code{object@@run}}
#'  \item{\code{scenarios}}{vector of harvest or harvest rate scenarios}
#'  \item{\code{time}}{complete series of time step labels}
#'  \item{\code{nsamples}}{number of posterior samples equal to \code{object@@nsamples}}
#'  \item{\code{biomass}}{array of biomass values with dimensions: iteration, time, scenario}
#'  \item{\code{depletion}}{array of depletion values with dimensions: iteration, time, scenario}
#'  \item{\code{epsilon_p}}{process error residual matrix}
#'  \item{\code{harvest}}{catch time series array}
#'  \item{\code{harvest_rate}}{harvest rate time series array}
#' }
#' @importFrom stats rnorm
#' @examples
#' \dontrun{
#' # get some data
#' data(haknz)
#' dat <- bdmData(harvest = haknz$landings, index = cbind(haknz$survey, haknz$cpue))
#' 
#' # initialize and fit default model
#' mdl <- bdm()
#' mdl <- compiler(mdl)
#' mdl <- sampler(mdl, dat, run = 'example_run')
#' 
#' # constant harvest rate projection scenarios
#' mdl.project <- project(mdl, harvest = c(0.05, 0.10, 0.15), time = 20, harvest_rate = TRUE)
#' 
#' # check label
#' mdl@@run
#' mdl.project$run
#' 
#' # extract median values
#' apply(mdl.project$depletion, 2:3, median)
#' apply(mdl.project$harvest, 2:3, median)
#' apply(mdl.project$harvest_rate, 2:3, median)
#' 
#' # constant catch projection scenarios
#' mdl.project <- project(mdl, harvest = c(900, 1200, 1500), time = 20, harvest_rate = FALSE)
#' 
#' # extract median values
#' apply(mdl.project$depletion, 2:3, median)
#' apply(mdl.project$harvest, 2:3, median)
#' apply(mdl.project$harvest_rate, 2:3, median)
#' }
#' 
#{{{ projection functions
#' @export
setGeneric("project", function(object, harvest_project, ...) standardGeneric("project"))
#{{ project from bdm object under constant harvest or harvest rate specified as a single value across all iterations
#' @rdname project
setMethod("project", signature = c("bdm", "vector"),function(object, harvest_project, time_project, harvest_rate = TRUE) {
  
  # dimensions
  # **********
  n_time       <- object@data$T
  n_total_time <- n_time + time_project
  n_scenarios  <- length(harvest_project)
  n_iter       <- object@nsamples
  
  d_time <- as.numeric(object@data$time)
  d_time <- c(d_time, (d_time[n_time] + 1):(d_time[n_time] + time_project))
  
  # harvest array
  # *************
  if (harvest_rate) {
    
    harvest <- array(0, dim = c(n_iter, n_total_time, n_scenarios))
    harvest[, 1:n_time,] <- object@trace$harvest_rate
    
    # replicate iterations along first dimension
    harvest[,(n_time + 1):n_total_time,] <- array(rep(as.vector(t(matrix(harvest_project,n_scenarios,time_project))),each = n_iter),dim=c(n_iter,time_project,n_scenarios))
    
  } else {
    
    harvest                             <- matrix(0,n_scenarios,n_total_time)
    harvest[,1:n_time]                  <- matrix(object@data$harvest,n_scenarios,n_time,byrow = TRUE)
    harvest[,(n_time + 1):n_total_time] <- matrix(harvest_project,n_scenarios,time_project)
    
    # replicate iterations along first dimension
    harvest <- array(rep(as.vector(t(harvest)),each = n_iter),dim = c(n_iter,n_total_time,n_scenarios))
  }
  
  # process error array
  # *******************
  ep <- array(0,dim = c(n_iter,n_total_time))
  ep[,1:n_time] <- object@trace$epsilon_p
  
  # process error sigma
  ep_sigma <- object@data$sigmap
  
  # default process error correlation
  # Thorson (2014) CJFAS
  rho <- 0.43
  
  # initialise array with LN random value
  # generated by rstan
  ep[,n_time + 1] <- rho * log(ep[,n_time] + ep_sigma^2/2) + sqrt(1 - rho^2) * rnorm(n_iter,0,ep_sigma)
  
  # correlated random variates on log scale
  for (t in (n_time + 2):n_total_time) {
    ep[,t] <- rho * ep[,t - 1] + sqrt(1 - rho^2) * rnorm(n_iter,0,ep_sigma)
  }
  
  # convert to natural scale
  ep[,(n_time + 1):n_total_time] <- exp(ep[,(n_time + 1):n_total_time] - ep_sigma^2/2)
  
  # depletion array
  # ***************
  x <- array(0,dim = c(n_iter,n_total_time,n_scenarios))
  x[,1:n_time,] <- object@trace$x
  
  for (s in 1:n_scenarios)
    for (t in (n_time+1):n_total_time)
      x[,t,s] <- .project_harvest(x[,t - 1,s],ep[,t - 1],harvest[,t - 1,s],harvest_rate,object)
  
  # return
  # ******
  dimnames(x)       <- list(iter = 1:n_iter,time = d_time,scenario = 1:n_scenarios)
  dimnames(ep)      <- list(iter = 1:n_iter,time = d_time)
  dimnames(harvest) <- list(iter = 1:n_iter,time = d_time,scenario = 1:n_scenarios)
  
  biomass <- apply(x,2:3,function(y) y * exp(object@trace$logK))
  dimnames(biomass) <- list(iter = 1:n_iter,time = d_time,scenario = 1:n_scenarios)
  
  if (harvest_rate) {
    list(run = object@run,scenarios = harvest_project,time = d_time,nsamples = n_iter,biomass = biomass,depletion = x,epsilon_p = ep,harvest = harvest*biomass,harvest_rate = harvest)
  } else {
    list(run = object@run,scenarios = harvest_project,time = d_time,nsamples = n_iter,biomass = biomass,depletion = x,epsilon_p = ep,harvest = harvest,harvest_rate = harvest/biomass)
  }
})
#{
.project_harvest <- function(x,ep,harvest,harvest_rate,object) {
  
  r    <- object@trace$r
  logK <- object@trace$logK
  dmsy <- object@trace$dmsy
  h    <- object@trace$h
  g    <- object@trace$g
  m    <- object@trace$m
  n    <- object@data$n
  
  if (harvest_rate) {
    pars <- data.frame(x = x,r = r,logK = logK,dmsy = dmsy,h = h,g = g,m = m,H = harvest*x,ep = ep)
  } else {
    pars <- data.frame(x = x,r = r,logK = logK,dmsy = dmsy,h = h,g = g,m = m,H = exp(log(harvest) - logK),ep = ep)
  }
  pars[,'H'] <- apply(pars,1,function(y) y['H'] <- min(y['H'],y['x']))
 
  x.out <- apply(pars,1,function(y) {
              if (y['x'] <= y['dmsy']) { max((y['x'] + y['r'] * y['x'] * (1 - y['x']/y['h']) - y['H'])*y['ep'],0.01)
              } else max((y['x'] + y['g'] * y['m'] * y['x'] * (1 - y['x']^(n - 1)) - y['H'])*y['ep'],0.01)
              })
    
  x.out
}
#}
#}}
#}}}


